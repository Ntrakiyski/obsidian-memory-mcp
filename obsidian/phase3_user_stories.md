# Phase 3: Scheduled Updates via Internal Agents
**Status**: ðŸ“… PLANNED (Target: After Phase 2 completion)
**Goal**: Automated daily/weekly updates generated by 0brainOS internal agents

---

## Overview

Phase 3 adds scheduled cognitive updates that are:
1. **Generated by 0brainOS internal agents** - Using PocketFlow AsyncFlow patterns
2. **Delivered via webhook** - POST to webhook with enhanced payload structure
3. **Configured via environment variables** - Set via Coolify, not dashboard UI

**IMPORTANT ARCHITECTURE CHANGE**:
- **Removed**: n8n webhook approach (Phase 3 original design)
- **Added**: Internal agents/flows in 0brainOS generate content directly
- **Kept**: Webhook delivery mechanism for Gmail/Telegram notifications

**The Three Scheduled Updates**:
- **Morning Briefing** (configurable time, default 7:00 AM)
- **Evening Recap** (configurable time, default 7:00 PM)
- **Sunday Weekly Review** (configurable time, default 7:00 AM)

**Key Design Decision**: Instead of delegating to n8n, 0brainOS now uses internal PocketFlow agents to generate the content. The webhook is used only for delivery (Gmail/Telegram), not content generation.

**Success Criteria**:
- âœ… Morning briefing generates content and sends notification
- âœ… Evening recap generates content and sends notification
- âœ… Sunday weekly review generates content and sends notification
- âœ… All times configurable via environment variables
- âœ… Each update can be toggled on/off via env vars
- âœ… Webhook payload uses enhanced structure (default_data + additional_data)
- âœ… Graceful handling if webhook unavailable

**Timeline**: 2-3 days of focused development (after Phase 2)

**Dependencies**: Phase 2 must be complete

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PHASE 3: SCHEDULED UPDATES                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Environment Variables (Configuration)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  MORNING_BRIEFING_ENABLED=true                           â”‚   â”‚
â”‚  â”‚  MORNING_BRIEFING_TIME=07:00                             â”‚   â”‚
â”‚  â”‚  MORNING_BRIEFING_SERVICE=gmail                          â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  EVENING_RECAP_ENABLED=true                              â”‚   â”‚
â”‚  â”‚  EVENING_RECAP_TIME=19:00                               â”‚   â”‚
â”‚  â”‚  EVENING_RECAP_SERVICE=telegram                         â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  WEEKLY_REVIEW_ENABLED=true                              â”‚   â”‚
â”‚  â”‚  WEEKLY_REVIEW_DAY=Sunday                               â”‚   â”‚
â”‚  â”‚  WEEKLY_REVIEW_TIME=07:00                               â”‚   â”‚
â”‚  â”‚  WEEKLY_REVIEW_SERVICE=gmail                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚                                    â”‚
â”‚                           â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Cron Job (Every 5 Minutes)                  â”‚   â”‚
â”‚  â”‚  - Check if update is due                               â”‚   â”‚
â”‚  â”‚  - If due: Trigger appropriate PocketFlow agent         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚                                    â”‚
â”‚                           â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  0brainOS (Python)                       â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚  PocketFlow Agents (AsyncFlow)                     â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  - morning_briefing_flow                           â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  - evening_recap_flow                              â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  - weekly_review_flow                              â”‚ â”‚   â”‚
â”‚  â”‚  â”‚                                                     â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  Each agent:                                        â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  1. Fetch memories from Neo4j                      â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  2. Generate content using LLM                     â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  3. POST to webhook with payload                   â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚                                    â”‚
â”‚                           â–¼                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Webhook Endpoint                      â”‚   â”‚
â”‚  â”‚  - Receives POST with enhanced payload                  â”‚   â”‚
â”‚  â”‚  - Routes to service (gmail/telegram)                   â”‚   â”‚
â”‚  â”‚  - Delivers notification/email                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## User Stories

### Story 1: Morning Briefing Agent (PocketFlow)

**As a** 0brainOS system
**I want to** run a morning briefing agent
**So that** I receive a daily summary via notification

**Acceptance Criteria**:
- [ ] PocketFlow AsyncFlow: `morning_briefing_flow`
- [ ] Queries Neo4j for yesterday's memories
- [ ] Generates briefing content using LLM (OpenRouter)
- [ ] POSTs to webhook with enhanced payload structure
- [ ] Triggered via cron when `MORNING_BRIEFING_TIME` matches (within 5-min window)
- [ ] Only runs if `MORNING_BRIEFING_ENABLED=true`
- [ ] Uses `MORNING_BRIEFING_SERVICE` (gmail|telegram) for payload
- [ ] Returns success/error message

**Technical Implementation**:
```python
# 0brainOS/src/flows/scheduled/morning_briefing.py

from datetime import datetime, timedelta
from pocketflow import AsyncNode, AsyncFlow
from src.database.queries.memory import get_memories_by_date_range
from src.utils.llm import get_openrouter_client
from src.utils.notifications import send_email_notification
import os

class FetchYesterdayMemoriesNode(AsyncNode):
    """Fetch memories from yesterday for the briefing."""

    async def exec_async(self, prep_res):
        driver = prep_res['neo4j_driver']
        yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")

        memories = await get_memories_by_date_range(
            driver,
            start_date=yesterday,
            end_date=yesterday,
            limit=50
        )

        return {'memories': memories, 'date': yesterday}

class GenerateBriefingContentNode(AsyncNode):
    """Generate the morning briefing content using LLM."""

    async def exec_async(self, prep_res):
        memories = prep_res['memories']
        date = prep_res['date']

        client = await get_openrouter_client()

        # Format memories for LLM
        memories_text = "\n".join([
            f"- [{m['sector']}] {m['content']}"
            for m in memories
        ])

        prompt = f"""
        Generate a morning briefing for {date} based on these memories:

        {memories_text}

        Create a concise briefing with:
        1. Key highlights (3-5 bullets)
        2. Sector breakdown
        3. Action items (if any)

        Keep it under 200 words.
        """

        response = await client.chat.completions.create(
            model=os.getenv("OPENROUTER_CREATIVE_MODEL", "anthropic/claude-sonnet-4"),
            messages=[
                {"role": "system", "content": "You are a briefing assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500
        )

        content = response.choices[0].message.content

        return {
            'content': content,
            'date': date,
            'memories_count': len(memories)
        }

class SendBriefingNotificationNode(AsyncNode):
    """Send the briefing via webhook."""

    async def exec_async(self, prep_res):
        briefing_data = prep_res

        service_type = os.getenv("MORNING_BRIEFING_SERVICE", "gmail")

        # Prepare webhook payload
        default_data = {
            "service_type": service_type,
            "current_date": briefing_data['date'],
            "timestamp": datetime.now().isoformat()
        }

        additional_data = {
            "subject": f"Morning Briefing - {briefing_data['date']}",
            "body": briefing_data['content'],
            "memories_count": briefing_data['memories_count'],
            "update_type": "morning_briefing"
        }

        # Send notification
        result = await send_email_notification(
            default_data=default_data,
            additional_data=additional_data
        )

        return {'notification_result': result}

# Create the flow
fetch_yesterday = FetchYesterdayMemoriesNode()
generate_content = GenerateBriefingContentNode()
send_notification = SendBriefingNotificationNode()

morning_briefing_flow = fetch_yesterday >> generate_content >> send_notification
```

---

### Story 2: Evening Recap Agent (PocketFlow)

**As a** 0brainOS system
**I want to** run an evening recap agent
**So that** I review today's activities

**Acceptance Criteria**:
- [ ] PocketFlow AsyncFlow: `evening_recap_flow`
- [ ] Queries Neo4j for today's memories
- [ ] Generates recap content using LLM
- [ ] POSTs to webhook with enhanced payload structure
- [ ] Triggered via cron when `EVENING_RECAP_TIME` matches
- [ ] Only runs if `EVENING_RECAP_ENABLED=true`
- [ ] Uses `EVENING_RECAP_SERVICE` (gmail|telegram) for payload

**Technical Implementation**:
```python
# 0brainOS/src/flows/scheduled/evening_recap.py

from datetime import datetime
from pocketflow import AsyncNode, AsyncFlow
from src.database.queries.memory import get_memories_by_date_range
from src.utils.llm import get_openrouter_client
from src.utils.notifications import send_email_notification
import os

class FetchTodayMemoriesNode(AsyncNode):
    """Fetch memories from today for the recap."""

    async def exec_async(self, prep_res):
        driver = prep_res['neo4j_driver']
        today = datetime.now().strftime("%Y-%m-%d")

        memories = await get_memories_by_date_range(
            driver,
            start_date=today,
            end_date=today,
            limit=100
        )

        return {'memories': memories, 'date': today}

class GenerateRecapContentNode(AsyncNode):
    """Generate the evening recap content using LLM."""

    async def exec_async(self, prep_res):
        memories = prep_res['memories']
        date = prep_res['date']

        client = await get_openrouter_client()

        # Group by sector
        by_sector = {}
        for m in memories:
            sector = m['sector']
            if sector not in by_sector:
                by_sector[sector] = []
            by_sector[sector].append(m)

        # Format for LLM
        sector_summary = "\n".join([
            f"{sector}: {len(items)} memories"
            for sector, items in by_sector.items()
        ])

        prompt = f"""
        Generate an evening recap for {date}:

        Sector breakdown:
        {sector_summary}

        Create a thoughtful recap that:
        1. Summarizes the day's key activities
        2. Highlights important decisions
        3. Notes any patterns or insights

        Keep it under 250 words.
        """

        response = await client.chat.completions.create(
            model=os.getenv("OPENROUTER_CREATIVE_MODEL"),
            messages=[
                {"role": "system", "content": "You are a reflective assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=600
        )

        content = response.choices[0].message.content

        return {
            'content': content,
            'date': date,
            'memories_count': len(memories),
            'by_sector': {k: len(v) for k, v in by_sector.items()}
        }

class SendRecapNotificationNode(AsyncNode):
    """Send the recap via webhook."""

    async def exec_async(self, prep_res):
        recap_data = prep_res

        service_type = os.getenv("EVENING_RECAP_SERVICE", "telegram")

        default_data = {
            "service_type": service_type,
            "current_date": recap_data['date'],
            "timestamp": datetime.now().isoformat()
        }

        additional_data = {
            "subject": f"Evening Recap - {recap_data['date']}",
            "body": recap_data['content'],
            "memories_count": recap_data['memories_count'],
            "sector_breakdown": recap_data['by_sector'],
            "update_type": "evening_recap"
        }

        result = await send_email_notification(
            default_data=default_data,
            additional_data=additional_data
        )

        return {'notification_result': result}

# Create the flow
fetch_today = FetchTodayMemoriesNode()
generate_recap = GenerateRecapContentNode()
send_recap = SendRecapNotificationNode()

evening_recap_flow = fetch_today >> generate_recap >> send_recap
```

---

### Story 3: Weekly Review Agent (PocketFlow)

**As a** 0brainOS system
**I want to** run a weekly review agent
**So that** I review the week's patterns

**Acceptance Criteria**:
- [ ] PocketFlow AsyncFlow: `weekly_review_flow`
- [ ] Queries Neo4j for this week's memories (last 7 days)
- [ ] Generates weekly summary using LLM
- [ ] POSTs to webhook with enhanced payload structure
- [ ] Triggered via cron when day + time matches
- [ ] Only runs if `WEEKLY_REVIEW_ENABLED=true`
- [ ] Uses `WEEKLY_REVIEW_SERVICE` (gmail|telegram) for payload

**Technical Implementation**:
```python
# 0brainOS/src/flows/scheduled/weekly_review.py

from datetime import datetime, timedelta
from pocketflow import AsyncNode, AsyncFlow
from src.database.queries.memory import get_memories_by_date_range
from src.utils.llm import get_openrouter_client
from src.utils.notifications import send_email_notification
import os

class FetchWeekMemoriesNode(AsyncNode):
    """Fetch memories from the past week."""

    async def exec_async(self, prep_res):
        driver = prep_res['neo4j_driver']

        # Get week start (7 days ago)
        week_start = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")
        today = datetime.now().strftime("%Y-%m-%d")

        memories = await get_memories_by_date_range(
            driver,
            start_date=week_start,
            end_date=today,
            limit=200
        )

        # Calculate week number
        week_number = datetime.now().isocalendar()[1]

        return {
            'memories': memories,
            'week_start': week_start,
            'week_end': today,
            'week_number': week_number
        }

class GenerateWeeklySummaryNode(AsyncNode):
    """Generate the weekly review content using LLM."""

    async def exec_async(self, prep_res):
        memories = prep_res['memories']

        client = await get_openrouter_client()

        # Group by sector
        by_sector = {}
        for m in memories:
            sector = m['sector']
            if sector not in by_sector:
                by_sector[sector] = []
            by_sector[sector].append(m)

        # Format for LLM
        sector_details = "\n".join([
            f"\n{sector} ({len(items)} memories):\n" +
            "\n".join([f"  - {m['content'][:80]}..." for m in items[:5]])
            for sector, items in sorted(by_sector.items())
        ])

        prompt = f"""
        Generate a weekly review (Week {prep_res['week_number']}, {prep_res['week_start']} to {prep_res['week_end']}):

        Memories by sector:{sector_details}

        Create a comprehensive weekly review that:
        1. Summarizes key activities by sector
        2. Identifies patterns and themes
        3. Highlights important decisions
        4. Notes areas of growth or concern
        5. Provides actionable insights for next week

        Keep it under 400 words.
        """

        response = await client.chat.completions.create(
            model=os.getenv("OPENROUTER_PLANNING_MODEL", "anthropic/claude-opus-4"),
            messages=[
                {"role": "system", "content": "You are a strategic analyst."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=1000
        )

        content = response.choices[0].message.content

        return {
            'content': content,
            'week_number': prep_res['week_number'],
            'memories_count': len(memories),
            'sector_breakdown': {k: len(v) for k, v in by_sector.items()}
        }

class SendWeeklyNotificationNode(AsyncNode):
    """Send the weekly review via webhook."""

    async def exec_async(self, prep_res):
        weekly_data = prep_res

        service_type = os.getenv("WEEKLY_REVIEW_SERVICE", "gmail")

        default_data = {
            "service_type": service_type,
            "current_date": datetime.now().strftime("%Y-%m-%d"),
            "timestamp": datetime.now().isoformat()
        }

        additional_data = {
            "subject": f"Weekly Review - Week {weekly_data['week_number']}",
            "body": weekly_data['content'],
            "memories_count": weekly_data['memories_count'],
            "sector_breakdown": weekly_data['sector_breakdown'],
            "week_number": weekly_data['week_number'],
            "update_type": "weekly_review"
        }

        result = await send_email_notification(
            default_data=default_data,
            additional_data=additional_data
        )

        return {'notification_result': result}

# Create the flow
fetch_week = FetchWeekMemoriesNode()
generate_summary = GenerateWeeklySummaryNode()
send_weekly = SendWeeklyNotificationNode()

weekly_review_flow = fetch_week >> generate_summary >> send_weekly
```

---

### Story 4: Enhanced Webhook Payload Structure

**As a** system
**I want to** send structured webhook payloads
**So that** the webhook handler can route to different services

**Acceptance Criteria**:
- [ ] Modify `send_email_notification` in `src/utils/notifications.py`
- [ ] Add `default_data` parameter with: `service_type`, `current_date`, `timestamp`
- [ ] Add `additional_data` parameter with: `subject`, `body`, and custom fields
- [ ] POST to webhook URL with combined payload
- [ ] Handle both gmail and telegram service types

**Technical Implementation**:
```python
# 0brainOS/src/utils/notifications.py

import httpx
import os
from typing import Dict, Any

async def send_email_notification(
    default_data: Dict[str, Any],
    additional_data: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Send notification via webhook with enhanced payload structure.

    Args:
        default_data: Required fields (service_type, current_date, timestamp)
        additional_data: Custom fields (subject, body, memories, etc.)

    Returns:
        Webhook response data
    """

    webhook_url = os.getenv("NOTIFICATION_WEBHOOK_URL")

    if not webhook_url:
        return {
            "success": False,
            "error": "NOTIFICATION_WEBHOOK_URL not configured"
        }

    # Combine into final payload
    payload = {
        "default_data": default_data,
        "additional_data": additional_data
    }

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                webhook_url,
                json=payload,
                headers={"Content-Type": "application/json"}
            )

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"HTTP {response.status_code}",
                    "details": response.text
                }

            return {
                "success": True,
                "status_code": response.status_code,
                "response": response.json() if response.text else {}
            }

    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }
```

**Webhook Payload Format**:
```json
{
  "default_data": {
    "service_type": "gmail|telegram",
    "current_date": "2026-01-20",
    "timestamp": "2026-01-20T07:00:00Z"
  },
  "additional_data": {
    "subject": "Morning Briefing - 2026-01-19",
    "body": "Key highlights:\n- Chose PostgreSQL for Project X...",
    "memories_count": 12,
    "sector_breakdown": {
      "Semantic": 5,
      "Procedural": 4,
      "Episodic": 3
    },
    "update_type": "morning_briefing"
  }
}
```

---

### Story 5: Environment Variable Configuration

**As a** system
**I want to** store scheduled update settings in environment variables
**So that** agents know when to run and where to send

**Acceptance Criteria**:
- [ ] Configuration via environment variables (set in Coolify)
- [ ] Settings include: enabled, time, service_type for each update
- [ ] Weekly review includes day of week
- [ ] Webhook URL shared across all updates
- [ ] Default values for all settings

**Environment Variables**:
```bash
# Webhook Configuration (shared)
NOTIFICATION_WEBHOOK_URL=https://your-webhook-endpoint.com/notify

# Morning Briefing
MORNING_BRIEFING_ENABLED=true
MORNING_BRIEFING_TIME=07:00
MORNING_BRIEFING_SERVICE=gmail

# Evening Recap
EVENING_RECAP_ENABLED=true
EVENING_RECAP_TIME=19:00
EVENING_RECAP_SERVICE=telegram

# Weekly Review
WEEKLY_REVIEW_ENABLED=true
WEEKLY_REVIEW_DAY=Sunday
WEEKLY_REVIEW_TIME=07:00
WEEKLY_REVIEW_SERVICE=gmail
```

**Helper Functions**:
```python
# 0brainOS/src/utils/scheduling.py

import os
from datetime import datetime
from typing import Dict, Any, Optional

def get_scheduled_config() -> Dict[str, Any]:
    """Load scheduled update configuration from environment variables."""

    return {
        'morning_briefing': {
            'enabled': os.getenv('MORNING_BRIEFING_ENABLED', 'false').lower() == 'true',
            'time': os.getenv('MORNING_BRIEFING_TIME', '07:00'),
            'service': os.getenv('MORNING_BRIEFING_SERVICE', 'gmail')
        },
        'evening_recap': {
            'enabled': os.getenv('EVENING_RECAP_ENABLED', 'false').lower() == 'true',
            'time': os.getenv('EVENING_RECAP_TIME', '19:00'),
            'service': os.getenv('EVENING_RECAP_SERVICE', 'telegram')
        },
        'weekly_review': {
            'enabled': os.getenv('WEEKLY_REVIEW_ENABLED', 'false').lower() == 'true',
            'day': os.getenv('WEEKLY_REVIEW_DAY', 'Sunday'),
            'time': os.getenv('WEEKLY_REVIEW_TIME', '07:00'),
            'service': os.getenv('WEEKLY_REVIEW_SERVICE', 'gmail')
        }
    }

def is_time_to_trigger(scheduled_time: str, window_minutes: int = 5) -> bool:
    """Check if current time is within the scheduled trigger window."""

    hour, minute = map(int, scheduled_time.split(':'))
    now = datetime.now()

    # Calculate time until next scheduled time
    scheduled_datetime = now.replace(hour=hour, minute=minute, second=0, microsecond=0)

    # If scheduled time has passed today, use it; otherwise use tomorrow
    if scheduled_datetime < now:
        scheduled_datetime += timedelta(days=1)

    diff_minutes = abs((now - scheduled_datetime).total_seconds() / 60)

    return diff_minutes <= window_minutes

def is_day_match(scheduled_day: str) -> bool:
    """Check if today matches the scheduled day."""

    day_map = {
        'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3,
        'Friday': 4, 'Saturday': 5, 'Sunday': 6
    }

    today = datetime.now().weekday()
    scheduled = day_map.get(scheduled_day, -1)

    return today == scheduled
```

---

### Story 6: MCP Tools for Manual Triggers

**As a** user
**I want to** manually trigger scheduled updates
**So that** I can test or run updates on demand

**Acceptance Criteria**:
- [ ] `trigger_morning_briefing()` - Manual trigger tool
- [ ] `trigger_evening_recap()` - Manual trigger tool
- [ ] `trigger_weekly_review()` - Manual trigger tool
- [ ] `get_scheduled_config()` - View current config
- [ ] Each tool returns flow execution result

**Technical Implementation**:
```python
# 0brainOS/src/tools/scheduled/__init__.py

from fastmcp import FastMCP
from src.flows.scheduled.morning_briefing import morning_briefing_flow
from src.flows.scheduled.evening_recap import evening_recap_flow
from src.flows.scheduled.weekly_review import weekly_review_flow
from src.utils.scheduling import get_scheduled_config
from src.database.connection import get_driver

def register_scheduled_tools(mcp: FastMCP) -> None:

    @mcp.tool
    async def trigger_morning_briefing() -> str:
        """Manually trigger the morning briefing agent."""

        config = get_scheduled_config()

        if not config['morning_briefing']['enabled']:
            return "â¸ï¸ Morning briefing is disabled (MORNING_BRIEFING_ENABLED=false)"

        try:
            shared = {
                'neo4j_driver': get_driver()
            }

            result = await morning_briefing_flow.run_async(shared)
            notification_result = result.get('notification_result', {})

            if notification_result.get('success'):
                return f"âœ… Morning briefing sent successfully"
            else:
                return f"âš ï¸ Morning briefing generated but notification failed: {notification_result.get('error')}"

        except Exception as e:
            return f"âŒ Morning briefing failed: {str(e)}"

    @mcp.tool
    async def trigger_evening_recap() -> str:
        """Manually trigger the evening recap agent."""

        config = get_scheduled_config()

        if not config['evening_recap']['enabled']:
            return "â¸ï¸ Evening recap is disabled (EVENING_RECAP_ENABLED=false)"

        try:
            shared = {
                'neo4j_driver': get_driver()
            }

            result = await evening_recap_flow.run_async(shared)
            notification_result = result.get('notification_result', {})

            if notification_result.get('success'):
                return f"âœ… Evening recap sent successfully"
            else:
                return f"âš ï¸ Evening recap generated but notification failed: {notification_result.get('error')}"

        except Exception as e:
            return f"âŒ Evening recap failed: {str(e)}"

    @mcp.tool
    async def trigger_weekly_review() -> str:
        """Manually trigger the weekly review agent."""

        config = get_scheduled_config()

        if not config['weekly_review']['enabled']:
            return "â¸ï¸ Weekly review is disabled (WEEKLY_REVIEW_ENABLED=false)"

        try:
            shared = {
                'neo4j_driver': get_driver()
            }

            result = await weekly_review_flow.run_async(shared)
            notification_result = result.get('notification_result', {})

            if notification_result.get('success'):
                week_num = result.get('week_number', datetime.now().isocalendar()[1])
                return f"âœ… Weekly review (Week {week_num}) sent successfully"
            else:
                return f"âš ï¸ Weekly review generated but notification failed: {notification_result.get('error')}"

        except Exception as e:
            return f"âŒ Weekly review failed: {str(e)}"

    @mcp.tool
    async def get_scheduled_config() -> str:
        """Get current scheduled update configuration."""

        config = get_scheduled_config()

        output = """
# Scheduled Updates Configuration

## Morning Briefing
- Enabled: {enabled}
- Time: {time}
- Service: {service}

## Evening Recap
- Enabled: {enabled}
- Time: {time}
- Service: {service}

## Weekly Review
- Enabled: {enabled}
- Day: {day}
- Time: {time}
- Service: {service}

## Webhook
- URL: {webhook_url}
        """.format(
            enabled=config['morning_briefing']['enabled'],
            time=config['morning_briefing']['time'],
            service=config['morning_briefing']['service'],
            enabled=config['evening_recap']['enabled'],
            time=config['evening_recap']['time'],
            service=config['evening_recap']['service'],
            enabled=config['weekly_review']['enabled'],
            day=config['weekly_review']['day'],
            time=config['weekly_review']['time'],
            service=config['weekly_review']['service'],
            webhook_url=os.getenv('NOTIFICATION_WEBHOOK_URL', 'Not configured')
        )

        return output.strip()
```

---

### Story 7: Cron Job for Scheduled Updates

**As a** system
**I want to** check every 5 minutes if agents should run
**So that** updates trigger automatically

**Acceptance Criteria**:
- [ ] Background task runs every 5 minutes
- [ ] Checks if current time matches scheduled time (within window)
- [ ] Checks if update is enabled
- [ ] Triggers appropriate PocketFlow agent
- [ ] Stores last run timestamp
- [ ] Logs execution results

**Technical Implementation**:
```python
# 0brainOS/src/tasks/scheduled_updates.py

import asyncio
from datetime import datetime
from fastmcp import FastMCP
from src.utils.scheduling import get_scheduled_config, is_time_to_trigger, is_day_match
from src.flows.scheduled.morning_briefing import morning_briefing_flow
from src.flows.scheduled.evening_recap import evening_recap_flow
from src.flows.scheduled.weekly_review import weekly_review_flow
from src.database.connection import get_driver

class ScheduledUpdatesManager:
    """Manager for scheduled update flows."""

    def __init__(self):
        self.last_runs = {
            'morning_briefing': None,
            'evening_recap': None,
            'weekly_review': None
        }

    async def check_and_trigger_updates(self):
        """Check all scheduled updates and trigger if due."""

        config = get_scheduled_config()
        triggered = []

        # Check morning briefing
        if config['morning_briefing']['enabled']:
            if self._should_trigger('morning_briefing', config['morning_briefing']['time']):
                result = await self._trigger_morning_briefing()
                triggered.append(('morning_briefing', result))
                self.last_runs['morning_briefing'] = datetime.now()

        # Check evening recap
        if config['evening_recap']['enabled']:
            if self._should_trigger('evening_recap', config['evening_recap']['time']):
                result = await self._trigger_evening_recap()
                triggered.append(('evening_recap', result))
                self.last_runs['evening_recap'] = datetime.now()

        # Check weekly review
        if config['weekly_review']['enabled']:
            day = config['weekly_review']['day']
            time = config['weekly_review']['time']
            if is_day_match(day) and self._should_trigger('weekly_review', time):
                result = await self._trigger_weekly_review()
                triggered.append(('weekly_review', result))
                self.last_runs['weekly_review'] = datetime.now()

        # Log results
        if triggered:
            for update_type, result in triggered:
                print(f"[Scheduled Updates] {update_type}: {result}")

    def _should_trigger(self, update_type: str, scheduled_time: str) -> bool:
        """Check if update should trigger."""

        # Check if we've already triggered today
        if self.last_runs[update_type] is not None:
            last_run = self.last_runs[update_type]
            if last_run.date() == datetime.now().date():
                return False  # Already triggered today

        # Check if we're within the time window
        return is_time_to_trigger(scheduled_time, window_minutes=5)

    async def _trigger_morning_briefing(self) -> str:
        try:
            shared = {'neo4j_driver': get_driver()}
            result = await morning_briefing_flow.run_async(shared)
            return "âœ… Success"
        except Exception as e:
            return f"âŒ Failed: {str(e)}"

    async def _trigger_evening_recap(self) -> str:
        try:
            shared = {'neo4j_driver': get_driver()}
            result = await evening_recap_flow.run_async(shared)
            return "âœ… Success"
        except Exception as e:
            return f"âŒ Failed: {str(e)}"

    async def _trigger_weekly_review(self) -> str:
        try:
            shared = {'neo4j_driver': get_driver()}
            result = await weekly_review_flow.run_async(shared)
            return "âœ… Success"
        except Exception as e:
            return f"âŒ Failed: {str(e)}"


# FastMCP background task
async def scheduled_updates_cron(mcp: FastMCP):
    """Run every 5 minutes to check and trigger scheduled updates."""

    manager = ScheduledUpdatesManager()

    async def cron_task():
        while True:
            try:
                await manager.check_and_trigger_updates()
            except Exception as e:
                print(f"[Scheduled Updates] Error: {e}")

            # Wait 5 minutes
            await asyncio.sleep(300)

    # Start as background task
    mcp.background_task(cron_task)
```

---

### Story 8: Database Query Helper for Date Range

**As a** system
**I want to** query memories by date range
**So that** agents can fetch relevant memories

**Acceptance Criteria**:
- [ ] Function: `get_memories_by_date_range(driver, start_date, end_date, limit)`
- [ ] Queries Neo4j for memories within date range
- [ ] Returns list of memory dictionaries
- [ ] Orders by created_at descending

**Technical Implementation**:
```python
# 0brainOS/src/database/queries/memory.py

from datetime import datetime
from typing import List, Dict, Any
from src.utils.schemas import MemorySchema

async def get_memories_by_date_range(
    driver,
    start_date: str,
    end_date: str,
    limit: int = 100
) -> List[Dict[str, Any]]:
    """
    Get memories within a date range.

    Args:
        driver: Neo4j driver
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)
        limit: Maximum number of memories to return

    Returns:
        List of memory dictionaries
    """

    query = """
        MATCH (b:Bubble)
        WHERE b.valid_to IS NULL
          AND b.created_at >= date($start_date)
          AND b.created_at <= date($end_date)
        RETURN b
        ORDER BY b.created_at DESC
        LIMIT $limit
    """

    async with driver.session() as session:
        result = await session.run(
            query,
            start_date=start_date,
            end_date=end_date,
            limit=limit
        )

        memories = []
        async for record in result:
            node = record["b"]
            memories.append({
                "id": node.get("id"),
                "content": node.get("content"),
                "sector": node.get("sector"),
                "salience": node.get("salience", 0.5),
                "created_at": node.get("created_at"),
                "observations": node.get("observations", []),
                "entities": node.get("entities", [])
            })

        return memories
```

---

## Technical Requirements

### New Dependencies

**0brainOS (Python)**:
- All dependencies already exist from Phase 2 (httpx, pocketflow, etc.)

### File Structure

**0brainOS**:
```
src/
â”œâ”€â”€ flows/
â”‚   â””â”€â”€ scheduled/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ morning_briefing.py     # Morning briefing flow
â”‚       â”œâ”€â”€ evening_recap.py        # Evening recap flow
â”‚       â””â”€â”€ weekly_review.py        # Weekly review flow
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ scheduled/
â”‚       â””â”€â”€ __init__.py              # Manual trigger tools
â”œâ”€â”€ tasks/
â”‚   â””â”€â”€ scheduled_updates.py         # Cron job manager
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ scheduling.py                # Time check helpers
â”‚   â””â”€â”€ notifications.py             # Enhanced webhook payload
â””â”€â”€ database/
    â””â”€â”€ queries/
        â””â”€â”€ memory.py                # Add get_memories_by_date_range
```

---

## Environment Variables Reference

```bash
# Webhook Configuration (Required)
NOTIFICATION_WEBHOOK_URL=https://your-webhook-endpoint.com/notify

# Morning Briefing (Optional, defaults shown)
MORNING_BRIEFING_ENABLED=true
MORNING_BRIEFING_TIME=07:00
MORNING_BRIEFING_SERVICE=gmail

# Evening Recap (Optional, defaults shown)
EVENING_RECAP_ENABLED=true
EVENING_RECAP_TIME=19:00
EVENING_RECAP_SERVICE=telegram

# Weekly Review (Optional, defaults shown)
WEEKLY_REVIEW_ENABLED=true
WEEKLY_REVIEW_DAY=Sunday
WEEKLY_REVIEW_TIME=07:00
WEEKLY_REVIEW_SERVICE=gmail
```

---

## Estimated Effort

| Story | Complexity | Effort |
|-------|------------|--------|
| Story 1: Morning Briefing Flow | Medium | 3 hours |
| Story 2: Evening Recap Flow | Medium | 2 hours |
| Story 3: Weekly Review Flow | Medium | 3 hours |
| Story 4: Enhanced Notification | Low | 1 hour |
| Story 5: Environment Config | Low | 1 hour |
| Story 6: Manual Trigger Tools | Low | 2 hours |
| Story 7: Cron Job Manager | Medium | 2 hours |
| Story 8: Date Range Query | Low | 1 hour |

**Total Estimated Effort**: 15 hours
**Timeline**: 2 days of focused development

---

## Success Metrics

**Phase 3 Complete When**:
- âœ… Morning briefing flow generates content and sends notification
- âœ… Evening recap flow generates content and sends notification
- âœ… Weekly review flow generates content and sends notification
- âœ… All times configurable via environment variables
- âœ… Updates can be toggled on/off via env vars
- âœ… Webhook payload uses enhanced structure (default_data + additional_data)
- âœ… Manual trigger tools work for all three updates
- âœ… Cron job checks every 5 minutes
- âœ… Errors handled gracefully (logged, continue)
- âœ… Configuration viewable via `get_scheduled_config` tool

---

## Architecture Comparison

### Old Design (n8n Webhooks)
```
Dashboard â†’ Config File â†’ Cron â†’ 0brainOS â†’ n8n Webhook
                                              â†“
                                          n8n generates content
```

### New Design (Internal Agents)
```
Environment Variables â†’ Cron â†’ 0brainOS PocketFlow Agents
                                        â†“
                                   Generate content internally
                                        â†“
                                   Webhook for delivery only
```

**Key Changes**:
- 0brainOS now generates content using OpenRouter LLM
- Webhook only handles delivery (Gmail/Telegram)
- No dependency on n8n
- Faster execution (single flow vs external workflow)
- More control over content generation

---

**Phase 3 Status**: ðŸ“… PLANNED
**Target**: After Phase 2 completion
**Dependencies**: Phase 1 âœ… | Phase 2 (must complete first)
**Estimated Start**: Week of 2026-01-27 or later
